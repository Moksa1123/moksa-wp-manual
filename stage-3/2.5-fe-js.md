# 02.05 JavaScript (ES6+) 核心 (DOM 操作、Fetch API)

嗨，歡迎來到 JavaScript 核心的第二個章節！在前一堂課，我們建立了對 ES6+ 語法的基本認識。今天，我們將深入探討 JavaScript 在瀏覽器中最強大的兩個功能：**DOM (Document Object Model) 操作**與 **Fetch API**。

這兩個主題是現代 WordPress 佈景主題與外掛開發的基石。無論是開發一個互動式的 Gutenberg 區塊、一個無需重新整理頁面就能提交的表單，還是一個動態載入文章的產品篩選器，你都離不開它們。

*   **DOM 操作**：讓你用程式碼去「讀取」和「修改」網頁上的任何 HTML 元素。
*   **Fetch API**：讓你從瀏覽器向遠端伺服器 (例如你的 WordPress 網站) 非同步地「請求」或「發送」資料。

準備好了嗎？讓我們開始把靜態的網頁變得生動起來！

---

### 第一部分：DOM 操作 - 讓你的網頁動起來

**DOM (Document Object Model)**，中文稱作「文件物件模型」。當瀏覽器載入一個 HTML 文件時，它會將整個文件結構轉換成一個樹狀的物件模型，這個模型就是 DOM。JavaScript 可以透過操作這個「物件」來改變網頁的內容與外觀。

``
*（示意圖：一張 HTML 結構與其對應的 DOM 樹狀結構圖，左邊是 `<div id="app"><h1>Hello</h1></div>`，右邊是樹狀圖顯示 document -> div#app -> h1 -> "Hello"）*

#### 步驟 1：選取 (Select) DOM 元素

要操作一個元素，你得先「抓到」它。就像你要移動一張桌子，得先用手抓住它一樣。

在現代 JavaScript (ES6+) 中，我們最常使用以下兩個方法來選取元素，它們都支援 CSS 選擇器語法，非常方便。

*   **`document.querySelector()`**: 選取**第一個**符合條件的元素。
*   **`document.querySelectorAll()`**: 選取**所有**符合條件的元素，並回傳一個 `NodeList` (類似陣列的集合)。

**範例：**

假設你的 HTML 長這樣：
```html
<div id="main-content">
    <h1 class="title">歡迎來到 MoksaWP</h1>
    <p>這是一段示範文字。</p>
    <ul>
        <li class="list-item">項目一</li>
        <li class="list-item">項目二</li>
    </ul>
</div>
```

你可以這樣選取它們：

```javascript
// 透過 ID 選取 (ID 在頁面上應是唯一的)
const mainContent = document.querySelector('#main-content');
console.log(mainContent);

// 透過 class 選取第一個 h1 元素
const pageTitle = document.querySelector('.title');
console.log(pageTitle);

// 透過標籤名稱選取 p 元素
const paragraph = document.querySelector('p');
console.log(paragraph);

// 選取所有的 .list-item 元素
const listItems = document.querySelectorAll('.list-item');
console.log(listItems); // 會得到一個 NodeList，包含兩個 <li> 元素

// 你可以像操作陣列一樣，遍歷 NodeList
listItems.forEach(item => {
    console.log(item.textContent); // .textContent 會取得元素內的純文字
});
```

> **Moksa 技巧**：盡可能使用 `querySelector` 和 `querySelectorAll`，它們比舊的 `getElementById` 或 `getElementsByClassName` 更靈活、更強大。

#### 步驟 2：操作 (Manipulate) DOM 元素

抓到元素後，你就可以對它為所欲為了！以下是幾個最常見的操作：

1.  **修改內容**
    *   `element.textContent`: 修改元素的**純文字**內容。它會忽略 HTML 標籤。
    *   `element.innerHTML`: 修改元素的 **HTML** 內容。**注意：** 如果你插入的內容來自使用者輸入，請務必做過濾，否則可能會有 XSS (跨站腳本) 的安全風險。

    ```javascript
    const pageTitle = document.querySelector('.title');

    // 修改文字
    pageTitle.textContent = 'MoksaWP 開發課程';

    // 修改 HTML (例如加上一個 <span>)
    pageTitle.innerHTML = 'MoksaWP <em>開發課程</em>';
    ```

2.  **修改樣式 (Style)**
    *   `element.style.property`: 直接修改元素的行內樣式 (inline style)。屬性名稱要用駝峰式命名 (e.g., `backgroundColor`)。
    *   `element.classList`: 透過新增/移除 CSS class 來改變樣式。**這是推薦的最佳實踐**。

    ```javascript
    const paragraph = document.querySelector('p');

    // 方法一：直接修改 style (較不推薦，除非是動態計算的樣式)
    paragraph.style.color = 'blue';
    paragraph.style.fontSize = '20px';

    // 方法二：操作 class (推薦！)
    // 假設你的 CSS 檔案裡有 .highlight { background-color: yellow; }
    paragraph.classList.add('highlight');    // 新增 class
    paragraph.classList.remove('highlight'); // 移除 class
    paragraph.classList.toggle('highlight'); // 如果有就移除，沒有就新增
    ```
    > **Moksa 技巧**：盡量將樣式定義在 CSS 檔案中，然後用 JavaScript 來切換 `class`。這讓你的程式碼職責分離，更容易維護。

3.  **修改屬性 (Attribute)**
    *   `element.getAttribute('attrName')`: 獲取屬性值。
    *   `element.setAttribute('attrName', 'value')`: 設定屬性值。
    *   `element.removeAttribute('attrName')`: 移除屬性。

    ```javascript
    // 假設有一個連結 <a id="my-link" href="https://example.com">舊連結</a>
    const myLink = document.querySelector('#my-link');
    
    // 獲取 href 屬性
    console.log(myLink.getAttribute('href')); // "https://example.com"

    // 修改 href 屬性
    myLink.setAttribute('href', 'https://moksaweb.com');
    
    // 新增 target 屬性，讓它在新分頁開啟
    myLink.setAttribute('target', '_blank');
    ```

#### 步驟 3：新增與移除 DOM 元素

你也可以動態地建立全新的元素，並將它們插入到頁面中。

1.  **`document.createElement('tagName')`**: 建立一個新的元素節點。
2.  **`parentElement.append(newElement)`**: 將新元素**附加**到指定父元素的**末尾**。

**範例：在我們的 `<ul>` 中新增第三個項目。**

```javascript
// 1. 選取父元素 <ul>
const list = document.querySelector('ul');

// 2. 建立新的 <li> 元素
const newItem = document.createElement('li');

// 3. 設定新元素的內容和 class
newItem.textContent = '項目三 (由 JS 新增)';
newItem.classList.add('list-item', 'new-item');

// 4. 將新元素附加到 <ul> 中
list.append(newItem);

// 5. 移除一個元素
// 假設我們要移除第一個項目
const firstItem = document.querySelector('.list-item');
if (firstItem) {
    firstItem.remove(); // 直接在元素上呼叫 .remove() 即可
}
```

``
*（示意圖：瀏覽器畫面顯示原本只有兩個項目的列表，在執行程式碼後，第一個項目被移除，並在末尾新增了第三個項目）*

---

### 第二部分：Fetch API - 與 WordPress 後端溝通

在現代網頁開發中，我們很少會讓使用者每次操作都重新整理整個頁面。取而代之的是，我們透過 JavaScript 在背景與伺服器交換資料，然後只更新頁面需要改變的部分。**Fetch API** 就是實現這項技術的標準瀏覽器功能。

**API (Application Programming Interface)** 就像是餐廳的菜單，它定義了你可以跟伺-服器「點」哪些資料、用什麼格式「點」。WordPress 就內建了一套強大的 **REST API**，讓我們可以透過 HTTP 請求來存取文章、頁面、使用者等各種資料。

#### 步驟 1：發起一個基本的 GET 請求

`fetch()` 是一個基於 **Promise** 的函式。Promise 簡單來說就是一個「承諾」，代表一個未來才會完成的非同步操作。

讓我們試著用 `fetch` 從一個公開的 API 獲取一些假資料。

```javascript
// 一個公開的測試用 API
const apiURL = 'https://jsonplaceholder.typicode.com/posts/1';

fetch(apiURL)
    .then(response => {
        // fetch 的第一個 .then 是處理 HTTP 回應本身
        // 我們需要檢查回應是否成功 (status 200-299)
        if (!response.ok) {
            throw new Error('網路回應錯誤');
        }
        // 將回應的 body 解析為 JSON 格式
        return response.json(); 
    })
    .then(data => {
        // 第二個 .then 才是處理我們真正拿到的 JSON 資料
        console.log('成功取得資料：', data);
        console.log('文章標題：', data.title);
    })
    .catch(error => {
        // 如果中間任何環節出錯 (網路問題、解析失敗等)，就會在這裡捕捉到
        console.error('取得資料失敗：', error);
    });
```
``
*（示意圖：瀏覽器開發者工具的 Console 面板，顯示成功印出的文章物件與標題）*

#### 步驟 2：使用 `async/await` 語法糖

雖然 `.then()` 的鏈式寫法很經典，但在 ES7 (ES2017) 之後，我們有了 `async/await` 這個語法糖，可以讓我們用更像同步程式碼的風格來寫非同步操作，可讀性更高。

> **Moksa 技巧**：在 Moksa 的專案中，我們**強烈建議**使用 `async/await` 來處理非同步請求，這會讓你的程式碼更乾淨、更易於除錯。

將上面的範例改寫成 `async/await`：

```javascript
// 必須在一個 async 函式中使用 await
async function getPostData() {
    const apiURL = 'https://jsonplaceholder.typicode.com/posts/1';

    try {
        // 使用 await "等待" fetch 完成
        const response = await fetch(apiURL);

        if (!response.ok) {
            throw new Error('網路回應錯誤');
        }

        // 使用 await "等待" JSON 解析完成
        const data = await response.json();

        console.log('成功取得資料 (async/await)：', data);
        console.log('文章標題：', data.title);

    } catch (error) {
        // try...catch 的作用等同於 .catch()
        console.error('取得資料失敗 (async/await)：', error);
    }
}

// 呼叫這個 async 函式
getPostData();
```

是不是看起來清爽多了？程式碼從上到下執行，就像我們習慣的閱讀順序一樣。

---

### 第三部分：Moksa 實戰應用 - AJAX 載入更多文章

現在，讓我們結合 DOM 操作和 Fetch API，來做一個 WordPress 開發中非常常見的功能：點擊按鈕，非同步載入更多文章。

**目標**：頁面上有一個按鈕，點擊後，使用 Fetch API 去請求 WordPress REST API 的文章資料，然後用 DOM 操作將文章標題動態地渲染到頁面上。

#### 步驟 1：準備 HTML 結構

在你的佈景主題樣板檔 (例如 `page.php` 或 `front-page.php`) 中，加入以下 HTML：

```html
<div class="posts-wrapper">
    <h2>最新文章</h2>
    <div id="posts-container">
        <!-- 文章將會被插入到這裡 -->
    </div>
    <button id="load-more-btn" class="button">載入更多</button>
</div>
```

#### 步驟 2：撰寫 JavaScript

在你的佈景主題 JavaScript 檔案中，加入以下程式碼：

```javascript
// 等待整個 DOM 載入完成後再執行
document.addEventListener('DOMContentLoaded', () => {

    // 1. 選取需要的 DOM 元素
    const postsContainer = document.querySelector('#posts-container');
    const loadMoreBtn = document.querySelector('#load-more-btn');

    // 如果頁面上找不到這些元素，就直接返回，避免錯誤
    if (!postsContainer || !loadMoreBtn) {
        return;
    }
    
    let currentPage = 1; // 用來追蹤目前載入到第幾頁

    // 2. 監聽按鈕的點擊事件
    loadMoreBtn.addEventListener('click', async () => {
        // 在 async 函式中執行我們的邏輯
        try {
            // 讓按鈕在載入時暫時失效，並改變文字
            loadMoreBtn.disabled = true;
            loadMoreBtn.textContent = '載入中...';

            // 3. 使用 Fetch API 請求 WordPress REST API
            // 你的網域/wp-json/wp/v2/posts?per_page=3&page=頁碼
            const response = await fetch(`/wp-json/wp/v2/posts?per_page=3&page=${currentPage}`);

            if (!response.ok) {
                throw new Error('無法從伺服器取得文章');
            }

            const posts = await response.json();
            
            // 如果沒有更多文章了
            if (posts.length === 0) {
                loadMoreBtn.textContent = '沒有更多文章了';
                return; // 直接結束函式
            }

            // 4. 操作 DOM，將文章渲染到頁面上
            posts.forEach(post => {
                // 建立一個 div 作為文章的容器
                const postElement = document.createElement('div');
                postElement.classList.add('post-item');

                // 建立標題
                const title = document.createElement('h3');
                // post.title.rendered 是 REST API 回傳的標題欄位
                title.innerHTML = post.title.rendered; 

                // 建立內容摘要
                const excerpt = document.createElement('div');
                excerpt.classList.add('post-excerpt');
                // post.excerpt.rendered 是摘要欄位
                excerpt.innerHTML = post.excerpt.rendered;

                // 將標題和摘要放入文章容器
                postElement.append(title);
                postElement.append(excerpt);

                // 將文章容器放入主容器
                postsContainer.append(postElement);
            });
            
            // 頁碼 +1，為下一次載入做準備
            currentPage++;

        } catch (error) {
            console.error('載入文章時發生錯誤:', error);
            postsContainer.innerHTML += '<p style="color: red;">載入失敗，請稍後再試。</p>';
        } finally {
            // 無論成功或失敗，最後都要恢復按鈕的狀態 (除非已經沒有更多文章)
            if (loadMoreBtn.textContent !== '沒有更多文章了') {
                loadMoreBtn.disabled = false;
                loadMoreBtn.textContent = '載入更多';
            }
        }
    });
});
```
> **Moksa 技巧**：`try...catch...finally` 結構非常實用。`finally` 區塊裡的程式碼，無論 `try` 是否成功執行，都**一定會**被執行。這非常適合用來做一些清理工作，例如恢復按鈕的狀態。

現在，當你在前端頁面點擊「載入更多」按鈕時，你就會看到文章被動態地載入進來，而整個頁面完全沒有刷新！這就是現代化 WordPress 開發的魅力所在。

### 總結

今天我們學習了 JavaScript 中兩個極其重要的部分：

1.  **DOM 操作**：透過 `querySelector` 選取元素，並使用 `textContent`, `innerHTML`, `classList`, `setAttribute` 來修改它們。我們也學會了如何用 `createElement` 和 `append` 動態新增元素。
2.  **Fetch API**：學會了如何使用 `fetch` 搭配 `async/await` 向伺服器 (特別是 WordPress REST API) 請求資料，並處理可能發生的錯誤。

熟練掌握這兩項技能，你將能夠為你的佈景主題和外掛打造出流暢、互動性強的使用者體驗。在接下來的課程中，我們將會不斷地用到這些觀念，尤其是在開發 Gutenberg 區塊和客製化後台介面時。請務必親自動手練習，加深理解！