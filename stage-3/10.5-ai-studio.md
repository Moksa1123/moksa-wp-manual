# 10.05 (實務) (Google AI Studio) 串接 API (Gemini API)

嗨，歡迎來到 MoksaWP 的開發者實戰課程！在之前的章節中，我們已經掌握了 WordPress 的底層邏輯與外掛開發的基礎。今天，我們要來做一件非常酷、而且極具商業價值的事情：**串接外部 API**。

我們將以目前最熱門的 Google AI 模型 **Gemini API** 為例，學習如何讓你的 WordPress 網站擁有生成式 AI 的能力。這項技能可以應用在非常多的地方，例如：
*   自動生成文章草稿或 SEO 標題。
*   為 WooCommerce 商品自動撰寫行銷文案。
*   建立一個智能問答客服機器人。
*   分析使用者評論的情緒...等等。

本章節的目標是帶你從零開始，完成從**取得 API 金鑰**、**撰寫安全的 PHP 程式碼**、到**建立一個實用的 Shortcode 短代碼**的完整流程。

---

### 前置準備

在開始之前，請確保你已經準備好以下項目：

1.  一個 Google 帳號。
2.  一個本地 WordPress 開發環境 (例如 **LocalWP**)。
3.  你的程式碼編輯器 (例如 **VS Code**)。

---

### 步驟 1：取得你的 Google Gemini API 金鑰 (API Key)

API 金鑰 (API Key) 就像是你用來跟 Google AI 服務溝通的「密碼」或「通行證」。任何 API 請求都必須附上這把鑰匙，Google 才知道是你發出的請求。

1.  **前往 Google AI Studio**
    *   請在瀏覽器中開啟 [Google AI Studio](https://aistudio.google.com/)。
    *   使用你的 Google 帳號登入。

2.  **取得 API 金鑰**
    *   登入後，點擊左上角的 `</> Get API key` 按鈕。
    ``

3.  **建立新的 API 金鑰**
    *   在彈出的視窗中，點擊 `Create API key in new project` 按鈕。
    ``
    *   系統會立刻生成一組獨一無二的字串，這就是你的 API 金鑰。

4.  **複製並妥善保管**
    *   **這非常重要！** 請立刻點擊複製按鈕，並將這組金鑰儲存在一個安全的地方（例如你的密碼管理器）。這個視窗關閉後，你將**無法再次看到完整的金鑰**。
    *   **資安警告：** **絕對不要**將你的 API 金鑰直接寫在佈景主題或外掛的 PHP 檔案中，更不要上傳到公開的 Git 儲存庫。我們稍後會教你最安全的存放方式。

---

### 步驟 2：安全地在 WordPress 中呼叫 API

現在我們有了金鑰，接下來就是在 WordPress 中撰寫程式碼來呼叫 Gemini API。我們將會使用 WordPress 內建的 **HTTP API** (`wp_remote_post`) 來發送請求，這是最標準且安全的方式。

#### 1. (Moksa 技巧) 使用 `wp-config.php` 安全地存放 API 金鑰

為了避免 API 金鑰外洩，最好的做法是將它定義在 `wp-config.php` 檔案中。這個檔案通常不會被納入版控，並且位於網站根目錄，相對安全。

1.  開啟你的 WordPress 網站根目錄下的 `wp-config.php` 檔案。
2.  在 `/* That's all, stop editing! Happy publishing. */` 這行註解的**上方**，加入以下程式碼：

    ```php
    /**
     * Google Gemini API Key for MoksaWP.
     */
    define( 'MOKSA_GEMINI_API_KEY', '貼上你剛剛複製的API金鑰' );
    ```

    *   **重要觀念：** 使用 `define()` 定義一個常數，可以讓你在網站的任何地方透過 `MOKSA_GEMINI_API_KEY` 這個常數來存取金鑰，而不需要將它寫死在程式碼中。

#### 2. 建立 API 呼叫函式

我們建議將所有與 API 相關的邏輯都封裝在一個獨立的函式中。你可以在你的自訂外掛或佈景主題的 `functions.php` 檔案中加入以下程式碼。

```php
<?php
/**
 * 呼叫 Google Gemini API 並回傳結果.
 *
 * @param string $prompt 使用者輸入的提示詞.
 * @return string AI 生成的內容或錯誤訊息.
 */
function moksa_call_gemini_api( $prompt ) {

    // 1. 檢查 API 金鑰是否存在
    if ( ! defined( 'MOKSA_GEMINI_API_KEY' ) || empty( MOKSA_GEMINI_API_KEY ) ) {
        return '錯誤：尚未設定 Gemini API 金鑰。';
    }

    // 2. 設定 API 端點 (Endpoint)
    // 我們使用 gemini-pro 模型
    $api_url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=' . MOKSA_GEMINI_API_KEY;

    // 3. 準備要傳送的資料 (Payload)
    // 根據 Gemini API 的文件，我們需要傳送一個 JSON 格式的 body
    $body = [
        'contents' => [
            [
                'parts' => [
                    [
                        'text' => $prompt,
                    ],
                ],
            ],
        ],
    ];

    // 4. 使用 WordPress HTTP API 發送請求
    $response = wp_remote_post( $api_url, [
        'method'    => 'POST',
        'headers'   => [ 'Content-Type' => 'application/json' ],
        'body'      => json_encode( $body ),
        'timeout'   => 30, // 增加超時時間，因為 AI 回應需要時間
    ] );

    // 5. 處理 API 回應
    if ( is_wp_error( $response ) ) {
        // 如果請求本身就失敗了 (例如網路問題)
        return '錯誤：API 請求失敗 - ' . $response->get_error_message();
    }

    $response_code = wp_remote_retrieve_response_code( $response );
    $response_body = wp_remote_retrieve_body( $response );
    $data = json_decode( $response_body );

    if ( $response_code !== 200 ) {
        // 如果 Google 回傳錯誤 (例如金鑰無效、額度用完)
        $error_message = isset( $data->error->message ) ? $data->error->message : '未知錯誤';
        return '錯誤：API 回傳錯誤 (代碼 ' . $response_code . ') - ' . $error_message;
    }
    
    // 6. 成功取得回應，解析出 AI 生成的文字
    // **重要觀念：** 這邊的結構是根據 Gemini API 回傳的 JSON 格式來解析的
    if ( isset( $data->candidates[0]->content->parts[0]->text ) ) {
        return $data->candidates[0]->content->parts[0]->text;
    } else {
        return '錯誤：無法解析 API 回應的內容。';
    }
}
```

**程式碼解說：**

*   我們首先檢查 `MOKSA_GEMINI_API_KEY` 是否已定義，確保金鑰存在。
*   `$api_url` 是 Gemini API 的**請求網址 (Endpoint)**，我們將金鑰附加在 URL 的最後。
*   `$body` 是我們要傳送給 AI 的**資料主體**，包含了我們的提示詞 (`$prompt`)。這個結構必須完全符合 Google 的 API 文件規範。
*   `wp_remote_post()` 是 WordPress 的核心函式，專門用來發送 `POST` 請求。我們設定了 `headers` (告訴對方我們傳的是 JSON)、`body` (將我們的 PHP 陣列轉為 JSON 字串)，以及 `timeout` (因為 AI 回應較慢，我們把超時時間設為 30 秒)。
*   **專業的錯誤處理**是非常重要的。我們分別檢查了：
    1.  `is_wp_error()`: 請求本身是否成功發送。
    2.  `$response_code`: Google 伺服器是否成功處理我們的請求 (HTTP 狀態碼 200 表示成功)。
*   最後，如果一切順利，我們就用 `json_decode()` 解析回傳的 JSON 資料，並從複雜的結構中取出我們真正需要的文字內容 `($data->candidates[0]->content->parts[0]->text)`。

---

### 步驟 3：(實作) 建立一個 AI 內容生成 Shortcode

現在我們有了一個強大的 `moksa_call_gemini_api()` 函式，但要如何讓不懂程式碼的網站編輯或行銷人員使用它呢？**Shortcode (短代碼)** 就是最好的橋樑！

我們的目標是建立一個像這樣的短代碼：
`[gemini_prompt prompt="請幫我寫一首關於 WooCommerce 的短詩"]`

網站編輯只要在文章編輯器中輸入這段短代碼，前台頁面就會自動顯示由 AI 生成的內容。

請將以下程式碼加入你的自訂外掛或 `functions.php` 中：

```php
<?php
/**
 * 註冊一個 Shortcode [gemini_prompt] 來呼叫 AI.
 *
 * @param array $atts Shortcode 的屬性.
 * @return string 處理後的內容.
 */
function moksa_gemini_shortcode_handler( $atts ) {
    
    // 1. 設定短代碼的預設屬性
    $atts = shortcode_atts( [
        'prompt' => '請介紹一下 WordPress 是什麼？', // 如果使用者沒有提供 prompt，就用這個預設值
    ], $atts, 'gemini_prompt' );

    // 2. 從屬性中取得 prompt
    $prompt = sanitize_text_field( $atts['prompt'] );

    // 3. 呼叫我們之前寫好的 API 函式
    $ai_response = moksa_call_gemini_api( $prompt );
    
    // 4. 將 AI 的回應美化一下再回傳
    // nl2br() 可以將 AI 回應中的換行符號 \n 轉為 HTML 的 <br> 標籤
    return '<div class="moksa-gemini-response">' . nl2br( esc_html( $ai_response ) ) . '</div>';
}
add_shortcode( 'gemini_prompt', 'moksa_gemini_shortcode_handler' );
```

**使用方式：**

1.  儲存你的 PHP 檔案。
2.  到 WordPress 後台，新增一篇文章或頁面。
3.  在內容編輯器中，輸入以下短代碼：

    ```
    [gemini_prompt prompt="用活潑的語氣，介紹 Moksa 的 WordPress 課程有什麼特色"]
    ```
4.  發布頁面並檢視前台。

``

你會看到頁面上顯示了由 Gemini AI 即時生成的一段介紹文字！

---

### 步驟 4：重要考量與 Moksa 技巧

雖然功能已經完成，但作為一個**資深開發者**，我們還需要考慮效能與成本問題。

#### 1. 效能與快取 (Performance & Caching)

每一次呼叫 Gemini API 都需要耗費 3-5 秒甚至更久的時間，而且通常是**需要付費的**。如果每次有訪客瀏覽頁面，我們都即時去呼叫一次 API，那網站速度會變得極慢，而且你的 API 帳單可能會爆表。

**Moksa 技巧：** 使用 **Transients API** 來快取 API 結果！

Transients API 是 WordPress 內建的快取機制。我們可以將 API 的結果暫時存放在資料庫中，並設定一個過期時間 (例如 24 小時)。在這段時間內，所有相同的請求都會直接從快取中讀取，而不會真的去呼叫 Google API。

修改我們的 Shortcode 函式，加入快取邏輯：

```php
<?php
function moksa_gemini_shortcode_handler_with_cache( $atts ) {
    
    $atts = shortcode_atts( [
        'prompt' => '請介紹一下 WordPress 是什麼？',
    ], $atts, 'gemini_prompt' );

    $prompt = sanitize_text_field( $atts['prompt'] );

    // 1. 建立一個獨一無二的 transient key
    // 我們用 prompt 的內容做 md5 hash，確保同樣的 prompt 會對應到同一個 key
    $transient_key = 'gemini_result_' . md5( $prompt );

    // 2. 檢查快取中是否有資料
    $cached_result = get_transient( $transient_key );

    if ( false !== $cached_result ) {
        // 如果快取存在，就直接回傳快取的結果！
        // 可以在 HTML 中加入一個註解，方便我們除錯時知道這是從快取來的
        return '<!-- From Cache --> <div class="moksa-gemini-response">' . $cached_result . '</div>';
    }

    // 3. 如果快取不存在，才真正去呼叫 API
    $ai_response = moksa_call_gemini_api( $prompt );

    // 4. 將 API 結果存入快取，並設定過期時間
    // DAY_IN_SECONDS 是 WordPress 內建常數，代表一天的秒數 (86400)
    // 我們將成功的結果快取 24 小時
    if ( strpos( $ai_response, '錯誤：' ) === false ) { // 只快取成功的結果
         set_transient( $transient_key, $ai_response, DAY_IN_SECONDS );
    }
    
    return '<div class="moksa-gemini-response">' . nl2br( esc_html( $ai_response ) ) . '</div>';
}

// 記得更新 add_shortcode 的函式名稱
// add_shortcode( 'gemini_prompt', 'moksa_gemini_shortcode_handler' ); // 舊的
add_shortcode( 'gemini_prompt', 'moksa_gemini_shortcode_handler_with_cache' ); // 新的
```

現在，當第一個訪客載入頁面時，系統會呼叫 API 並將結果快取 24 小時。之後 24 小時內的所有訪客，都會在毫秒之間從資料庫讀取到相同的結果，大幅提升網站效能並節省 API 費用。

### 總結

恭喜你！在本章節中，你已經學會了串接外部 API 的完整流程，這是在 WordPress 開發領域中一項非常進階且強大的技能。

我們回顧一下重點：
1.  從 Google AI Studio 成功申請並取得了 **API Key**。
2.  學會了最安全的作法：將 API Key 存放在 **`wp-config.php`** 中。
3.  使用 WordPress 標準的 **`wp_remote_post()`** 函式來發送 API 請求，並做了完整的錯誤處理。
4.  將複雜的後端邏輯封裝成一個簡單易用的 **Shortcode**，方便內容編輯者使用。
5.  **(Moksa 核心技巧)** 導入了 **Transients API** 來做快取，兼顧了網站效能與 API 成本。

這只是個開始，你可以基於今天的所學，發揮創意去打造更多有趣的 AI 應用。例如，在 WooCommerce 的商品編輯頁面新增一個按鈕，點擊後自動調用 Gemini API 為商品生成銷售文案，並填入編輯器中。繼續探索吧！