# 09.03 (實作) 打造您的第一個「靜態 Block」

嗨，歡迎來到 Gutenberg 開發的世界！在前面的單元中，我們理解了 Block Editor 的基本概念與運作原理。現在，是時候動手打造屬於我們自己的第一個 Block 了。

在這個實作單元中，我們將會學習使用 WordPress 官方推薦的工具，從無到有建立一個**靜態 Block (Static Block)**。所謂的靜態 Block，指的是它的內容（HTML）在儲存時就已經決定，並直接寫入文章的 `post_content` 欄位。這與需要後端 PHP 動態渲染的「動態 Block」相對，是學習 Block 開發最理想的起點。

我們的目標是建立一個名為「Moksa 資訊卡」的簡單 Block，它包含一個可編輯的標題和一段可編輯的內文。

---

### 前置準備與環境

在開始之前，請確保你的開發環境已經準備就緒。這是 **Moksa 開發技術棧** 的標準配備：

1.  **本機環境:** **LocalWP** 已經安裝並建立好一個新的 WordPress 網站。
2.  **程式碼編輯器:** **Visual Studio Code (VS Code)**。
3.  **執行環境:** **Node.js** 與 **npm**。這是執行 JavaScript 編譯工具的必要環境。你可以開啟終端機，輸入 `node -v` 和 `npm -v` 來確認是否已安裝。
4.  **終端機 (Terminal / Command Line):** 我們會需要使用命令列工具來執行指令。

---

### 步驟 1: 使用官方工具建立 Block 樣板

過去，從零開始設定 Block 的開發環境（Webpack, Babel, React 等）非常繁瑣。幸運的是，WordPress 核心團隊提供了一個強大的腳手架工具 `@wordpress/create-block`，可以一鍵生成完整的 Block 開發環境。

1.  開啟你的終端機 (Terminal)。
2.  使用 `cd` 指令，將路徑切換到你 LocalWP 網站的 **外掛資料夾**。路徑通常會像這樣： `~/Local Sites/你的網站名稱/app/public/wp-content/plugins/`。
3.  執行以下指令來建立我們的 Block 外掛：

    ```bash
    npx @wordpress/create-block moksa-info-card
    ```

    *   `npx` 是一個 npm 的工具，可以讓你執行套件指令而不需要全域安裝。
    *   `@wordpress/create-block` 是官方的腳手架工具名稱。
    *   `moksa-info-card` 是我們為這個 Block 外掛指定的資料夾名稱（也稱為 "slug"）。

4.  執行後，你會看到終端機開始下載並安裝所有需要的檔案。完成後，會顯示成功的訊息。

``
*(截圖：終端機顯示 `npx @wordpress/create-block` 指令成功執行的畫面)*

現在，你的 `plugins` 資料夾底下已經多了一個 `moksa-info-card` 的新資料夾，這就是一個完整、可以獨立運作的 Block 外掛。

### 步驟 2: 認識 Block 的檔案結構

讓我們用 VS Code 打開 `moksa-info-card` 這個資料夾，看看裡面產生了哪些檔案。理解這些檔案的用途至關重要。

```
moksa-info-card/
├── build/              # 經過編譯後的最終 JS 和 CSS 檔案
├── node_modules/       # 所有開發依賴的套件
├── src/                # ✨ 我們的開發原始碼都放在這裡！
│   ├── block.json      # ✨ Block 的核心設定檔 (非常重要)
│   ├── edit.js         # ✨ 定義 Block 在編輯器中的樣貌與行為 (React)
│   ├── editor.scss     # Block 在編輯器中的專用樣式
│   ├── index.js        # Block 的主要進入點，負責註冊
│   ├── save.js         # ✨ 定義 Block 儲存時的 HTML 結構 (React)
│   └── style.scss      # Block 在前台與後台共用的樣式
├── .editorconfig
├── .gitignore
├── moksa-info-card.php # PHP 主檔案，負責在後端註冊 Block
├── package.json        # Node.js 專案設定檔，定義依賴與指令
└── readme.txt
```

**Moksa 技巧：** 現階段，你**只需要專注於 `src/` 資料夾**中的 `block.json`, `edit.js`, `save.js` 以及兩個 `.scss` 檔案。這是 90% 開發工作會發生的地點。

### 步驟 3: 修改 `block.json` - Block 的身份證

`block.json` 是 Block 的「元數據 (Metadata)」設定檔，它告訴 WordPress 這個 Block 的一切，是現代 Block 開發的**單一事實來源 (Single Source of Truth)**。

打開 `src/block.json`，我們來修改它，讓它符合我們的「Moksa 資訊卡」需求。

**修改前：**
```json
{
	"$schema": "https://schemas.wp.org/trunk/block.json",
	"apiVersion": 2,
	"name": "create-block/moksa-info-card",
	"version": "0.1.0",
	"title": "Moksa Info Card",
	"category": "widgets",
	"icon": "smiley",
	"description": "Example block scaffolded with Create Block tool.",
	"supports": {
		"html": false
	},
	"textdomain": "moksa-info-card",
	"editorScript": "file:./index.js",
	"editorStyle": "file:./index.css",
	"style": "file:./style-index.css"
}
```

**修改後：**
```json
{
	"$schema": "https://schemas.wp.org/trunk/block.json",
	"apiVersion": 2,
	"name": "moksa/info-card",
	"version": "0.1.0",
	"title": "Moksa 資訊卡",
	"category": "moksa-blocks",
	"icon": "info-outline",
	"description": "一個用來顯示帶有標題與內容的資訊卡片。",
	"supports": {
		"html": false
	},
    "attributes": {
        "cardTitle": {
            "type": "string",
            "source": "html",
            "selector": "h3"
        },
        "cardContent": {
            "type": "string",
            "source": "html",
            "selector": "p"
        }
    },
	"textdomain": "moksa-info-card",
	"editorScript": "file:./index.js",
	"editorStyle": "file:./index.css",
	"style": "file:./style-index.css"
}
```

**修改重點說明：**

*   `"name"`: Block 的唯一識別名稱，格式為 `namespace/block-name`。我們改為更有意義的 `moksa/info-card`。
*   `"title"`: 在編輯器中顯示的名稱，我們改為「**Moksa 資訊卡**」。
*   `"category"`: Block 歸類的分類。我們可以自訂一個分類，例如 `moksa-blocks`，方便管理。
*   `"icon"`: 圖示。你可以使用內建的 [Dashicons](https://developer.wordpress.org/resource/dashicons/) 名稱。
*   `"attributes"`: **這是最重要的部分**。它定義了這個 Block 會儲存哪些「資料」。
    *   我們定義了 `cardTitle` 和 `cardContent` 兩個屬性。
    *   `type`: 資料類型，這裡是 `string` (字串)。
    *   `source`: 資料來源，`html` 表示我們要從 HTML 元素中抓取內容。
    *   `selector`: 指定要從哪個 HTML 標籤抓取，例如 `h3` 和 `p`。

### 步驟 4: 撰寫 `edit.js` - 編輯器中的樣貌

這個檔案使用 React (JSX 語法) 來定義 Block 在後台編輯器中的樣子和互動行為。

打開 `src/edit.js`，將內容完全替換成以下程式碼：

```javascript
import { __ } from '@wordpress/i18n';
import { useBlockProps, RichText } from '@wordpress/block-editor';
import './editor.scss';

export default function Edit({ attributes, setAttributes }) {
	const blockProps = useBlockProps();
	const { cardTitle, cardContent } = attributes;

	const onChangeTitle = (newTitle) => {
		setAttributes({ cardTitle: newTitle });
	};

	const onChangeContent = (newContent) => {
		setAttributes({ cardContent: newContent });
	};

	return (
		<div {...blockProps}>
			<RichText
				tagName="h3"
				placeholder={__('請輸入卡片標題...', 'moksa-info-card')}
				value={cardTitle}
				onChange={onChangeTitle}
				allowedFormats={['core/bold', 'core/italic']}
			/>
			<RichText
				tagName="p"
				placeholder={__('請輸入卡片內容...', 'moksa-info-card')}
				value={cardContent}
				onChange={onChangeContent}
			/>
		</div>
	);
}
```

**程式碼解析：**

*   我們從 `@wordpress/block-editor` 匯入了 `useBlockProps` 和 `RichText`。
*   `useBlockProps()`: 這是一個必要的 Hook，它會為你的 Block 根元素加上所有 WordPress 需要的 class 和屬性。
*   `attributes`: 這個 props 包含了我們在 `block.json` 中定義的所有屬性值。
*   `setAttributes`: 這是一個函式，用來更新 `attributes` 的值。**當 `attributes` 改變時，React 會重新渲染 Block，並且 WordPress 會將變更儲存起來**。
*   `RichText`: 這是 Gutenberg 提供的核心元件，可以讓我們建立一個**可編輯的區域**，就像一個迷你版的編輯器。
    *   `tagName`: 指定這個 `RichText` 渲染成哪個 HTML 標籤。
    *   `value`: 綁定到我們的 `attributes`。
    *   `onChange`: 當使用者輸入內容時，觸發這個函式，我們呼叫 `setAttributes` 來更新資料。

### 步驟 5: 撰寫 `save.js` - 儲存到資料庫的 HTML

這個檔案也使用 React，但它的任務很單純：**根據傳入的 `attributes`，回傳最終要儲存到資料庫的 HTML 結構**。

打開 `src/save.js`，將內容完全替換成以下程式碼：

```javascript
import { useBlockProps, RichText } from '@wordpress/block-editor';

export default function save({ attributes }) {
	const blockProps = useBlockProps.save();
	const { cardTitle, cardContent } = attributes;

	return (
		<div {...blockProps}>
			<RichText.Content tagName="h3" value={cardTitle} />
			<RichText.Content tagName="p" value={cardContent} />
		</div>
	);
}
```

**程式碼解析：**

*   **Moksa 技巧：** `save` 函式**絕對不能包含任何互動或 state**。它是一個純粹的函式，給定相同的 `attributes`，就必須回傳相同的 HTML 結構。
*   注意這裡使用的是 `useBlockProps.save()`，這是儲存時專用的版本。
*   我們使用 `RichText.Content` 元件，它只會單純地輸出 `attributes` 的內容，而不會提供編輯功能。
*   這裡輸出的 HTML 結構，必須與 `edit.js` 的結構以及 `block.json` 中 `attributes` 的 `selector` 互相匹配，否則會發生 Block 驗證錯誤 (Validation Error)。

### 步驟 6: 加入簡單的樣式 (`style.scss`)

為了讓我們的卡片在前台看起來更美觀，我們可以編輯 `src/style.scss` 檔案，加入一些 CSS。這個檔案的樣式會同時應用在前端和後端編輯器。

```scss
.wp-block-moksa-info-card {
	border: 1px solid #ddd;
	border-left: 5px solid #007cba;
	padding: 1em 1.5em;
	background-color: #f9f9f9;
	margin-bottom: 1.5em;

	h3 {
		margin-top: 0;
		color: #1e1e1e;
	}
}
```

### 步驟 7: 編譯與測試 Block

我們已經修改完了所有原始碼，但這些是 `.js` 和 `.scss` 檔案，瀏覽器無法直接讀取。我們需要將它們「編譯」成瀏覽器看得懂的格式。

1.  回到你的終端機，確保你還在 `moksa-info-card` 這個資料夾路徑底下。
2.  執行開發指令：

    ```bash
    npm start
    ```

    這個指令會啟動一個監聽程序。它會立刻編譯一次所有檔案到 `build` 資料夾，並且**持續監控 `src` 資料夾的任何變動，只要你一存檔，它就會自動重新編譯**。這在開發階段非常方便。

3.  前往 WordPress 後台的「外掛」頁面，找到「Moksa Info Card」並**啟用**它。

``
*(截圖：WordPress 後台外掛頁面，顯示已啟用 Moksa Info Card)*

4.  新增或編輯任何一篇文章或頁面，進入 Block Editor。
5.  點擊「+」號來新增區塊，在搜尋框中輸入「Moksa」或「資訊卡」，你應該就能找到我們剛剛建立的 Block。

``
*(截圖：Block 編輯器中，成功搜尋到「Moksa 資訊卡」)*

6.  點擊插入它，試著編輯標題和內容，然後儲存文章。
7.  前往前台查看這篇文章，你應該會看到一個帶有我們剛才設定樣式的資訊卡片！

``
*(截圖：文章前台顯示帶有藍色左框線的「Moksa 資訊卡」)*

---

### Moksa 技巧 & 總結

恭喜你！你已經成功地使用現代化的 WordPress 開發流程，建立了你的第一個客製化 Gutenberg Block。

**本單元重點回顧：**

1.  **善用工具：** 我們學會了使用官方的 `@wordpress/create-block` 工具來快速建立 Block 開發環境，省去了繁瑣的環境設定。
2.  **`block.json` 是核心：** 所有的 Block 設定、名稱、圖示，特別是**資料結構 (`attributes`)**，都定義在這個檔案中。
3.  **`edit` 與 `save` 的分離：** 我們理解了 `edit.js` 負責後台編輯器的互動體驗，而 `save.js` 則負責定義最終儲存的靜態 HTML。這是 Block 開發的核心思想。
4.  **`RichText` 元件：** 我們學會使用 `RichText` 來創造可讓使用者自由編輯的區域，並將其內容與 `attributes` 綁定。
5.  **編譯流程：** 了解 `npm start` 在開發中的重要性，它能即時反映我們的程式碼變更。當要正式上線時，可以執行 `npm run build` 來產生最佳化過的產品版本。

這僅僅是個開始。接下來的單元，我們將會探索更複雜的 Block 功能，例如側邊欄控制項 (Inspector Controls)、動態 Block、以及與 WordPress REST API 的互動。繼續加油！