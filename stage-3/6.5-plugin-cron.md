# 06.05 (實務) WP Cron (排程任務)

你好，我是 Moksa 的首席課程導師。在這一堂實務課程中，我們將深入探討 WordPress 開發中一個非常強大但也容易被誤解的功能：**WP-Cron**。

簡單來說，WP-Cron 是 WordPress 內建的排程系統，它讓你的網站能夠在特定的時間自動執行某些任務，例如：每日備份、定時發布文章、發送電子報、或清理資料庫。這對於網站自動化維運至關重要。

---

### 什麼是 WP-Cron？它與「真正的」Cron Job 有何不同？

在我們開始寫程式碼之前，你必須先理解一個**核心觀念**：

*   **真正的 Cron Job**：這是由主機作業系統（例如 Linux）提供的服務。你可以設定一個任務在「2023年12月25日 凌晨 00:00:00」準時執行，無論網站有沒有訪客，時間一到，主機就會強制執行它。這是**時間驅動 (Time-driven)** 的。

*   **WP-Cron**：這並不是一個一直在背景運行的服務。它的運作原理是：**當有任何訪客瀏覽你的網站時**，WordPress 會檢查當下是否有「已經過期」但尚未執行的排程任務。如果有，它就會在**這次的頁面載入過程中**一併執行這些任務。這是**事件驅動 (Action-driven) 或訪客驅動 (Visitor-driven)** 的。

**這個差異帶來了幾個重要的影響：**

1.  **不保證準時**：如果你的網站流量很低，半夜完全沒有人訪問，那麼設定在半夜三點執行的任務，可能會延遲到早上八點第一個訪客來臨時才被執行。
2.  **可能影響效能**：如果一個排程任務非常耗時（例如產生複雜報表），而它剛好在一位訪客瀏覽頁面時被觸發，那麼這位訪客可能會感覺到網站載入速度明顯變慢。

儘管有這些限制，WP-Cron 仍然是執行非絕對精準時間任務的絕佳工具。在我們的 Moksa 技術棧中，許多外掛都依賴它運作：

*   **UpdraftPlus**：執行排程備份。
*   **FluentCRM**：發送自動化的 Email 序列信。
*   **WooCommerce**：排程特價商品的開始與結束。
*   **WP Rocket**：預先載入快取頁面。

---

### (實作) 如何建立一個自訂的排程任務

現在，讓我們來實作一個常見的開發需求：**建立一個每小時執行一次的自訂任務**。假設我們的任務是「檢查是否有新註冊的會員，並將名單寫入一個 Log 檔」。

我們將在你的自訂外掛或佈景主題的 `functions.php` 中完成這件事。

#### 步驟 1：建立要執行的函式 (Hook Callback)

首先，我們要定義當排程任務被觸發時，到底要執行什麼程式碼。

```php
/**
 * 我們排程任務要執行的主要函式
 * 這裡的範例是將當前時間寫入到一個 log 檔案中
 */
function moksa_custom_hourly_task_function() {
    // 使用 wp_get_upload_dir() 取得上傳資料夾的路徑，這是比較安全的做法
    $upload_dir = wp_get_upload_dir();
    $log_file = $upload_dir['basedir'] . '/moksa_cron_log.txt';
    
    // 取得當前時間（記得設定時區）
    $current_time = new DateTime('now', new DateTimeZone('Asia/Taipei'));
    $log_message = 'WP-Cron Task Executed at: ' . $current_time->format('Y-m-d H:i:s') . "\n";
    
    // 將訊息附加到檔案中
    file_put_contents($log_file, $log_message, FILE_APPEND);
}

// 將我們的函式掛載到一個自訂的 action hook 上
// 這個 'moksa_custom_hourly_task' 就是我們排程事件的唯一識別名稱
add_action( 'moksa_custom_hourly_task', 'moksa_custom_hourly_task_function' );
```

**Moksa 技巧**：我們不直接呼叫函式，而是透過 `add_action` 將它掛載到一個我們自己命名的鉤點 `moksa_custom_hourly_task` 上。這是 WordPress 的標準做法，讓程式碼更有彈性、更容易擴充。

#### 步驟 2：在外掛啟用時，註冊排程事件

我們不希望每次頁面載入時都重新註冊一次排程。最好的時機點是在**外掛啟用時**設定好，之後 WordPress 就會記住它。

```php
/**
 * 在外掛啟用時執行的函式
 */
function moksa_plugin_activation() {
    // 檢查這個排程事件是否已經存在，如果不存在才建立
    if ( ! wp_next_scheduled( 'moksa_custom_hourly_task' ) ) {
        wp_schedule_event( time(), 'hourly', 'moksa_custom_hourly_task' );
    }
}
// 使用 register_activation_hook 來指定外掛啟用時要執行的函式
register_activation_hook( __FILE__, 'moksa_plugin_activation' );

```

讓我們來分解 `wp_schedule_event()` 這個重要的函式：

*   `time()`: **首次執行的時間**。`time()` 代表「現在」，所以它會立刻排入佇列，並在下次有訪客時嘗試執行。你也可以給它一個未來的 UNIX 時間戳。
*   `'hourly'`: **重複的頻率**。WordPress 內建了 `'hourly'` (每小時)、`'twicedaily'` (每 12 小時)、`'daily'` (每天)。
*   `'moksa_custom_hourly_task'`: **要觸發的 Action Hook 名稱**。這個名稱必須跟步驟 1 `add_action` 中使用的名稱完全一樣。

#### 步驟 3：(選用) 新增自訂的時間間隔

如果內建的頻率不符合你的需求（例如：每 5 分鐘、每週），你可以自訂。

```php
/**
 * 新增自訂的 WP-Cron 時間間隔
 * @param array $schedules
 * @return array
 */
function moksa_add_custom_cron_interval( $schedules ) {
    $schedules['every_five_minutes'] = array(
        'interval' => 300, // 秒數 (5 * 60)
        'display'  => esc_html__( 'Every Five Minutes' ),
    );
    return $schedules;
}
add_filter( 'cron_schedules', 'moksa_add_custom_cron_interval' );
```

加上這段程式碼後，你在 `wp_schedule_event()` 中就可以使用 `'every_five_minutes'` 作為頻率了。

#### 步驟 4：在外掛停用時，清除排程事件

這是一個**非常重要但經常被忽略的步驟**。如果使用者停用了你的外掛，你應該要把你建立的排程任務清除掉，避免它成為一個「孤兒排程」，在資料庫中留下垃圾。

```php
/**
 * 在外掛停用時執行的函式
 */
function moksa_plugin_deactivation() {
    // 取得下一次排程的時間戳
    $timestamp = wp_next_scheduled( 'moksa_custom_hourly_task' );
    // 清除排程
    wp_clear_scheduled_hook( 'moksa_custom_hourly_task' );
}
// 使用 register_deactivation_hook 來指定外掛停用時要執行的函式
register_deactivation_hook( __FILE__, 'moksa_plugin_deactivation' );
```

---

### 管理與偵錯 WP-Cron

寫好排程後，我們要如何確認它是否正常運作？

#### 方法一：使用外掛 (WP Crontrol)

對於初學者或需要快速查看的場景，安裝 [WP Crontrol](https://wordpress.org/plugins/wp-crontrol/) 外掛是最簡單的方式。

1.  安裝並啟用 WP Crontrol。
2.  到後台「**工具**」>「**Cron 事件**」。
3.  你可以在這裡看到網站中所有已註冊的排程事件，包括你剛才建立的 `moksa_custom_hourly_task`。
4.  你可以看到它的**鉤點名稱**、**下一次執行時間**、**重複頻率**。
5.  你也可以手動點擊「**立即執行**」來測試你的函式是否正常。

````
(這是一張 WP Crontrol 外掛介面的截圖，顯示了 `moksa_custom_hourly_task` 事件的列表)
````

#### 方法二：使用 WP-CLI (Moksa 開發者必備)

對於專業開發者，使用 **WP-CLI (WordPress Command-Line Interface)** 是更有效率的方式。這是我們 Moksa 開發流程的標準工具。

打開你的終端機 (Terminal) 或 VS Code 內建的終端機，進入你的 WordPress 網站根目錄，執行以下指令：

```bash
# 列出所有已排程的 cron 事件
wp cron event list

# 只看我們自訂的事件
wp cron event list | grep 'moksa'

# 手動執行一次我們的事件進行測試
wp cron event run moksa_custom_hourly_task

# 刪除我們的事件
wp cron event delete moksa_custom_hourly_task
```

使用 WP-CLI 不需要登入後台，反應速度快，非常適合在開發與伺服器維護時使用。

---

### (進階) Moksa 最佳實踐：使用系統 Cron 取代 WP-Cron

前面提到，WP-Cron 依賴訪客流量，這對穩定性要求高的任務是個隱患。例如，如果你的網站是 B2B 服務，週末完全沒人訪問，那週末的排程任務就全部停擺了。

**最佳解法是：停用內建的 WP-Cron 觸發機制，改用主機的「真實 Cron Job」來定時呼叫 WordPress。**

#### 步驟 1：停用內建的 WP-Cron

打開你網站根目錄的 `wp-config.php` 檔案，在 `/* That's all, stop editing! Happy publishing. */` 這一行之前，加入以下程式碼：

```php
define('DISABLE_WP_CRON', true);
```

這行程式碼會告訴 WordPress：「不要再因為訪客瀏覽而自己檢查排程了，我會從外部手動觸發你。」

#### 步驟 2：設定伺服器的 Cron Job

接下來，你需要登入你的主機控制台（例如 cPanel, Plesk）或透過 SSH 連線來設定一個真實的 Cron Job。

你需要設定一個**每 5 到 15 分鐘**執行一次的指令。指令的內容如下：

```bash
# 使用 wget 的範例
wget -q -O - https://yourdomain.com/wp-cron.php?doing_wp_cron >/dev/null 2>&1

# 或者，使用 curl 的範例
curl -s 'https://yourdomain.com/wp-cron.php?doing_wp_cron' >/dev/null 2>&1
```

*   請將 `https://yourdomain.com` 換成你自己的網址。
*   這個指令的目的就是模擬一個「外部請求」去訪問 `wp-cron.php` 這個檔案。
*   `>/dev/null 2>&1` 的意思是告訴伺服器，不要儲存任何執行結果或錯誤訊息，保持安靜執行即可。

````
(這是一張 cPanel 的 Cron Job 設定介面截圖，顯示了時間設定為 "*/5 * * * *" 並且指令欄位填入了上面的 wget 指令)
````

完成這兩步後，你的網站排程系統就變得非常強健可靠了。它不再依賴不穩定的訪客流量，而是由主機每隔幾分鐘就準確地來「叫醒」WordPress 檢查一次是否有任務要做。**這是所有正式上線的專業網站都應該採用的標準設定**。

### 總結

今天我們完整學習了 WP-Cron 的運作原理與實務應用。你學會了：

1.  WP-Cron 與真實 Cron Job 的**核心差異**。
2.  如何使用 `wp_schedule_event` 和 `add_action` **建立一個自訂的排程任務**。
3.  **啟用與停用外掛時**管理排程的生命週期，這是寫出乾淨程式碼的關鍵。
4.  使用 **WP Crontrol** 與 **WP-CLI** 來管理和偵錯你的排程。
5.  最終，學會了**停用內建 WP-Cron 並改用系統 Cron Job** 的 Moksa 最佳實踐，大幅提升任務執行的可靠性。

掌握 WP-Cron 是你從一位普通網站管理者邁向專業 WordPress 開發者的重要一步。下次當你需要網站自動執行某項工作時，你就知道該如何實現了。