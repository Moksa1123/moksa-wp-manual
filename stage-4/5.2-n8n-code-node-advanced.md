# 05.02 n8n 進階技巧：Code 節點的 JavaScript 應用 (資料處理與邏輯判斷)

嗨，歡迎來到 n8n 與 WordPress 協作的進階課程！在前幾堂課中，我們學會了如何使用 n8n 內建的節點來串接各種服務。然而，在真實的自動化情境中，你很快會發現，單靠內建節點有時會遇到瓶頸。例如：

*   來源服務給的資料格式不是你想要的。
*   你需要根據複雜的條件來決定下一步的動作。
*   你需要合併多個來源的資料，進行運算後再輸出。

這時候，n8n 的「瑞士刀」—— **Code 節點** 就派上用場了。這個節點讓你能夠直接用 **JavaScript** 來處理資料，賦予你的自動化流程無限的可能性。

---

### 學習目標

*   了解 Code 節點的基本運作原理與資料結構。
*   學會使用 JavaScript 進行基礎的**資料處理**（Data Processing），例如：重組、格式化文字。
*   學會使用 JavaScript 進行**邏輯判斷**（Logical Judgment），例如：`if/else` 條件判斷。
*   掌握幾個實用的 **Moksa 技巧**，讓你的 Code 節點更穩定、更強大。

### 先備知識

在開始之前，我們假設你已經具備：

1.  **基礎的 JavaScript 知識**：了解變數、陣列、物件、迴圈 (`for`)、條件判斷 (`if/else`)。
2.  **熟悉 n8n 的資料結構**：知道 n8n 的資料是以 `items` 陣列傳遞，且每個 item 包含 `json` 和 `binary` 兩個部分。

如果你對 n8n 資料結構還不熟悉，請務必複習前面的章節。

---

### 1. Code 節點的核心觀念

當資料流進 Code 節點時，它會被打包成一個名為 `items` 的陣列。你的任務就是用 JavaScript 處理這個 `items` 陣列，然後 `return` 一個**新的**陣列，傳遞給下一個節點。

``
*（Code 節點的預設畫面，可以看到左邊是輸入，右邊是程式碼編輯區）*

**三個最重要的觀念：**

1.  **輸入 (`items`)**: `items` 是一個陣列，裡面包含了從上一個節點傳來的所有項目。即使只有一筆資料，它也會被包在一個陣列中，所以你要用 `items[0]` 來取得第一筆資料。
2.  **資料本體 (`item.json`)**: 每一筆 `item` 的核心資料都存放在 `.json` 這個屬性裡面。所以，要取得第一筆資料的 `name` 欄位，你會用 `items[0].json.name`。
3.  **輸出 (`return`)**: 你的程式碼**必須** `return` 一個陣列。這個陣列的結構通常和你收到的 `items` 類似，這樣 n8n 才能繼續將它傳遞下去。最常見的作法是修改完 `items` 後，直接 `return items;`。

> **Moksa 技巧**：忘記 `return` 是新手最常犯的錯誤。如果你的 Code 節點執行後，下一個節點收不到任何資料，第一件事就是檢查你是否在程式碼的結尾正確地 `return` 了一個陣列。

---

### 2. (實作) 資料處理：為 LINE Notify 格式化 WooCommerce 訂單訊息

在我們的技術棧中，常常會用 WooCommerce 的 Webhook 觸發 n8n 流程，然後發送 LINE 通知給管理者。但 WooCommerce 傳來的原始訂單資料非常複雜，我們需要將它整理成一條簡潔易讀的訊息。

**目標**：將收到的 WooCommerce 新訂單資料，整理成一行摘要，方便發送到 LINE。

*   **原始資料 (模擬)**：
    ```json
    {
      "id": 1234,
      "total": "1580.00",
      "billing": {
        "first_name": "文傑",
        "last_name": "林"
      },
      "line_items": [
        { "name": "Moksa 獨家咖啡豆", "quantity": 2 },
        { "name": "專業手沖濾紙", "quantity": 1 }
      ]
    }
    ```
*   **目標格式**：
    `新訂單通知：林文傑 先生/小姐，訂單金額 $1580，購買商品：Moksa 獨家咖啡豆 x 2, 專業手沖濾紙 x 1`

#### 步驟 1：建立基本流程

1.  在你的 n8n 畫布上，新增一個 `Manual` (手動觸發) 節點，方便我們測試。
2.  在 `Manual` 節點後方，新增一個 **Code** 節點並將它們連接起來。

#### 步驟 2：在 Code 節點中撰寫 JavaScript

點開 Code 節點，將右方的程式碼全部清空，貼上以下程式碼。我們會在註解中詳細解釋每一行。

```javascript
// n8n 的資料是以 items 陣列傳入，即使只有一筆資料也是陣列
// 我們先取得第一筆資料來處理
const item = items[0];

// 為了方便測試，我們先手動定義一筆模擬的 WooCommerce 訂單資料
// 正常情況下，這筆資料會從 Webhook 或 WooCommerce Trigger 節點傳入 item.json 中
item.json = {
  "id": 1234,
  "total": "1580.00",
  "billing": {
    "first_name": "文傑",
    "last_name": "林"
  },
  "line_items": [
    { "name": "Moksa 獨家咖啡豆", "quantity": 2 },
    { "name": "專業手沖濾紙", "quantity": 1 }
  ]
};


// --- 主要處理邏輯開始 ---

// 從 item.json 中提取我們需要的欄位
const customerName = item.json.billing.last_name + item.json.billing.first_name;
const orderTotal = item.json.total;

// 使用 for 迴圈來處理訂單中的多個商品 (line_items)
let productDetails = []; // 建立一個空陣列來存放商品字串
for (const product of item.json.line_items) {
  productDetails.push(`${product.name} x ${product.quantity}`);
}

// 使用 .join(', ') 將商品陣列組合成一個字串
const productString = productDetails.join(', ');

// 使用樣板字串 (Template Literals) 來組合最終的通知訊息
const notificationMessage = `新訂單通知：${customerName} 先生/小姐，訂單金額 $${orderTotal}，購買商品：${productString}`;

// **最重要的一步**：將處理好的訊息，存回 item.json 的一個新欄位中
item.json.lineMessage = notificationMessage;

// **絕對不能忘記**：將處理完的 item (或 items) 陣列 return 出去
return items;
```

#### 步驟 3：執行與驗證

1.  點擊 Code 節點右上角的「Execute Node」按鈕。
2.  執行成功後，切換到右邊的「Output」分頁。
3.  你會看到原本的 `json` 資料中，多了一個我們剛剛建立的 `lineMessage` 欄位，其內容就是我們格式化好的訊息字串。

``
*（Code 節點的 Output 畫面，顯示 json 物件中新增了 lineMessage 欄位）*

現在，在後續的 `LINE Notify` 節點中，你就可以直接取用 `{{ $json.lineMessage }}` 這個變數來發送清爽的通知了！

---

### 3. (實作) 邏輯判斷：根據訂單金額給予客戶不同標籤

另一個常見的應用是 CRM 整合。例如，我們希望在 [**FluentCRM**](https://fluentcrm.com/) 中，根據 WooCommerce 的訂單金額，自動為客戶貼上不同的標籤 (Tag)。

**目標**：

*   如果訂單金額 > $2000，給予 `VIP 客戶` 標籤。
*   如果訂單金額 <= $2000，給予 `一般客戶` 標籤。

#### 步驟 1：修改 Code 節點的程式碼

延續上一個範例，我們在原有的程式碼下方，加入 `if/else` 邏輯判斷。

```javascript
// ... (延續上面的程式碼) ...

// --- 邏輯判斷區塊 ---

// **Moksa 技巧**：從 WooCommerce 來的金額通常是字串，
// 進行數字比較前，最好使用 parseFloat() 轉型為浮點數，確保比較正確。
const orderTotalFloat = parseFloat(item.json.total);

let crmTag = ''; // 宣告一個變數來儲存標籤名稱

if (orderTotalFloat > 2000) {
  crmTag = 'VIP 客戶';
} else {
  crmTag = '一般客戶';
}

// 將判斷完的結果，存到 item.json 的新欄位 crmTag 中
item.json.crmTag = crmTag;

// 將處理完的 items 陣列 return 出去
return items;
```

#### 步驟 2：執行與驗證

1.  再次執行 Code 節點。
2.  檢查 Output，你會發現 `json` 物件中現在同時有 `lineMessage` 和 `crmTag` 兩個新欄位。
3.  你可以試著修改模擬資料中的 `total` 金額 (例如改成 `2500.00`)，然後重新執行，看看 `crmTag` 的值是否會跟著改變成 `VIP 客戶`。

``
*（Code 節點的 Output 畫面，顯示 json 物件中新增了 crmTag 欄位，值為 "一般客戶"）*

有了 `crmTag` 這個欄位，你就可以在後續的 `FluentCRM` 節點中，動態地將這個標籤新增給對應的聯絡人了。

---

### 4. 進階技巧與最佳實踐 (Moksa 技巧)

1.  **使用 `console.log()` 來除錯**：
    當你的程式碼很複雜，或是不確定某個變數的內容時，可以在 Code 節點中使用 `console.log()`。
    ```javascript
    console.log("收到的 item 資料：", item.json);
    const customerName = item.json.billing.last_name;
    console.log("客戶姓氏：", customerName);
    ```
    執行節點後，你可以在 n8n 的編輯器介面右下角的「Logs」分頁，或是瀏覽器的開發者工具 (F12) 的 Console 中看到這些輸出的訊息，這對於除錯非常有幫助。

2.  **處理多筆資料**：
    如果上一個節點可能回傳多筆資料 (例如：從 Google Sheets 讀取多列)，你需要用 `for` 迴圈來遍歷整個 `items` 陣列。
    ```javascript
    for (const item of items) {
      // 在這裡對每一筆 item.json 進行處理
      const name = item.json.firstName;
      item.json.fullName = name + ' Doe';
    }
    return items;
    ```

3.  **保持資料純粹**：
    一個好的原則是，Code 節點只專注於「**資料處理**」。盡量不要在 Code 節點裡直接去呼叫外部 API。呼叫 API 的工作應該交給下一個 `HTTP Request` 節點。Code 節點的角色是幫 `HTTP Request` 節點準備好它需要的資料格式。

### 總結

Code 節點是打通 n8n 自動化任督二脈的關鍵。它可能一開始看起來有點嚇人，但一旦你掌握了 `items` 輸入和 `return` 輸出的核心觀念，就能夠客製化幾乎任何你想要的邏輯。

從今天起，當你發現內建節點無法滿足你的需求時，不要猶豫，勇敢地打開 Code 節點，用幾行 JavaScript 解決問題吧！這將會是你成為 n8n 高手的必經之路。